/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunknature_cam"] = self["webpackChunknature_cam"] || []).push([["vendors-node_modules_globby_index_js"],{

/***/ "./node_modules/ignore/index.js":
/*!**************************************!*\
  !*** ./node_modules/ignore/index.js ***!
  \**************************************/
/***/ ((module) => {

eval("// A simple implementation of make-array\nfunction makeArray (subject) {\n  return Array.isArray(subject)\n    ? subject\n    : [subject]\n}\n\nconst EMPTY = ''\nconst SPACE = ' '\nconst ESCAPE = '\\\\'\nconst REGEX_TEST_BLANK_LINE = /^\\s+$/\nconst REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\\\]|^)\\\\$/\nconst REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\\\!/\nconst REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\\\#/\nconst REGEX_SPLITALL_CRLF = /\\r?\\n/g\n// /foo,\n// ./foo,\n// ../foo,\n// .\n// ..\nconst REGEX_TEST_INVALID_PATH = /^\\.*\\/|^\\.+$/\n\nconst SLASH = '/'\n\n// Do not use ternary expression here, since \"istanbul ignore next\" is buggy\nlet TMP_KEY_IGNORE = 'node-ignore'\n/* istanbul ignore else */\nif (typeof Symbol !== 'undefined') {\n  TMP_KEY_IGNORE = Symbol.for('node-ignore')\n}\nconst KEY_IGNORE = TMP_KEY_IGNORE\n\nconst define = (object, key, value) =>\n  Object.defineProperty(object, key, {value})\n\nconst REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g\n\nconst RETURN_FALSE = () => false\n\n// Sanitize the range of a regular expression\n// The cases are complicated, see test cases for details\nconst sanitizeRange = range => range.replace(\n  REGEX_REGEXP_RANGE,\n  (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0)\n    ? match\n    // Invalid range (out of order) which is ok for gitignore rules but\n    //   fatal for JavaScript regular expression, so eliminate it.\n    : EMPTY\n)\n\n// See fixtures #59\nconst cleanRangeBackSlash = slashes => {\n  const {length} = slashes\n  return slashes.slice(0, length - length % 2)\n}\n\n// > If the pattern ends with a slash,\n// > it is removed for the purpose of the following description,\n// > but it would only find a match with a directory.\n// > In other words, foo/ will match a directory foo and paths underneath it,\n// > but will not match a regular file or a symbolic link foo\n// >  (this is consistent with the way how pathspec works in general in Git).\n// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'\n// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call\n//      you could use option `mark: true` with `glob`\n\n// '`foo/`' should not continue with the '`..`'\nconst REPLACERS = [\n\n  [\n    // remove BOM\n    // TODO:\n    // Other similar zero-width characters?\n    /^\\uFEFF/,\n    () => EMPTY\n  ],\n\n  // > Trailing spaces are ignored unless they are quoted with backslash (\"\\\")\n  [\n    // (a\\ ) -> (a )\n    // (a  ) -> (a)\n    // (a \\ ) -> (a  )\n    /\\\\?\\s+$/,\n    match => match.indexOf('\\\\') === 0\n      ? SPACE\n      : EMPTY\n  ],\n\n  // replace (\\ ) with ' '\n  [\n    /\\\\\\s/g,\n    () => SPACE\n  ],\n\n  // Escape metacharacters\n  // which is written down by users but means special for regular expressions.\n\n  // > There are 12 characters with special meanings:\n  // > - the backslash \\,\n  // > - the caret ^,\n  // > - the dollar sign $,\n  // > - the period or dot .,\n  // > - the vertical bar or pipe symbol |,\n  // > - the question mark ?,\n  // > - the asterisk or star *,\n  // > - the plus sign +,\n  // > - the opening parenthesis (,\n  // > - the closing parenthesis ),\n  // > - and the opening square bracket [,\n  // > - the opening curly brace {,\n  // > These special characters are often called \"metacharacters\".\n  [\n    /[\\\\$.|*+(){^]/g,\n    match => `\\\\${match}`\n  ],\n\n  [\n    // > a question mark (?) matches a single character\n    /(?!\\\\)\\?/g,\n    () => '[^/]'\n  ],\n\n  // leading slash\n  [\n\n    // > A leading slash matches the beginning of the pathname.\n    // > For example, \"/*.c\" matches \"cat-file.c\" but not \"mozilla-sha1/sha1.c\".\n    // A leading slash matches the beginning of the pathname\n    /^\\//,\n    () => '^'\n  ],\n\n  // replace special metacharacter slash after the leading slash\n  [\n    /\\//g,\n    () => '\\\\/'\n  ],\n\n  [\n    // > A leading \"**\" followed by a slash means match in all directories.\n    // > For example, \"**/foo\" matches file or directory \"foo\" anywhere,\n    // > the same as pattern \"foo\".\n    // > \"**/foo/bar\" matches file or directory \"bar\" anywhere that is directly\n    // >   under directory \"foo\".\n    // Notice that the '*'s have been replaced as '\\\\*'\n    /^\\^*\\\\\\*\\\\\\*\\\\\\//,\n\n    // '**/foo' <-> 'foo'\n    () => '^(?:.*\\\\/)?'\n  ],\n\n  // starting\n  [\n    // there will be no leading '/'\n    //   (which has been replaced by section \"leading slash\")\n    // If starts with '**', adding a '^' to the regular expression also works\n    /^(?=[^^])/,\n    function startingReplacer () {\n      // If has a slash `/` at the beginning or middle\n      return !/\\/(?!$)/.test(this)\n        // > Prior to 2.22.1\n        // > If the pattern does not contain a slash /,\n        // >   Git treats it as a shell glob pattern\n        // Actually, if there is only a trailing slash,\n        //   git also treats it as a shell glob pattern\n\n        // After 2.22.1 (compatible but clearer)\n        // > If there is a separator at the beginning or middle (or both)\n        // > of the pattern, then the pattern is relative to the directory\n        // > level of the particular .gitignore file itself.\n        // > Otherwise the pattern may also match at any level below\n        // > the .gitignore level.\n        ? '(?:^|\\\\/)'\n\n        // > Otherwise, Git treats the pattern as a shell glob suitable for\n        // >   consumption by fnmatch(3)\n        : '^'\n    }\n  ],\n\n  // two globstars\n  [\n    // Use lookahead assertions so that we could match more than one `'/**'`\n    /\\\\\\/\\\\\\*\\\\\\*(?=\\\\\\/|$)/g,\n\n    // Zero, one or several directories\n    // should not use '*', or it will be replaced by the next replacer\n\n    // Check if it is not the last `'/**'`\n    (_, index, str) => index + 6 < str.length\n\n      // case: /**/\n      // > A slash followed by two consecutive asterisks then a slash matches\n      // >   zero or more directories.\n      // > For example, \"a/**/b\" matches \"a/b\", \"a/x/b\", \"a/x/y/b\" and so on.\n      // '/**/'\n      ? '(?:\\\\/[^\\\\/]+)*'\n\n      // case: /**\n      // > A trailing `\"/**\"` matches everything inside.\n\n      // #21: everything inside but it should not include the current folder\n      : '\\\\/.+'\n  ],\n\n  // normal intermediate wildcards\n  [\n    // Never replace escaped '*'\n    // ignore rule '\\*' will match the path '*'\n\n    // 'abc.*/' -> go\n    // 'abc.*'  -> skip this rule,\n    //    coz trailing single wildcard will be handed by [trailing wildcard]\n    /(^|[^\\\\]+)(\\\\\\*)+(?=.+)/g,\n\n    // '*.js' matches '.js'\n    // '*.js' doesn't match 'abc'\n    (_, p1, p2) => {\n      // 1.\n      // > An asterisk \"*\" matches anything except a slash.\n      // 2.\n      // > Other consecutive asterisks are considered regular asterisks\n      // > and will match according to the previous rules.\n      const unescaped = p2.replace(/\\\\\\*/g, '[^\\\\/]*')\n      return p1 + unescaped\n    }\n  ],\n\n  [\n    // unescape, revert step 3 except for back slash\n    // For example, if a user escape a '\\\\*',\n    // after step 3, the result will be '\\\\\\\\\\\\*'\n    /\\\\\\\\\\\\(?=[$.|*+(){^])/g,\n    () => ESCAPE\n  ],\n\n  [\n    // '\\\\\\\\' -> '\\\\'\n    /\\\\\\\\/g,\n    () => ESCAPE\n  ],\n\n  [\n    // > The range notation, e.g. [a-zA-Z],\n    // > can be used to match one of the characters in a range.\n\n    // `\\` is escaped by step 3\n    /(\\\\)?\\[([^\\]/]*?)(\\\\*)($|\\])/g,\n    (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE\n      // '\\\\[bar]' -> '\\\\\\\\[bar\\\\]'\n      ? `\\\\[${range}${cleanRangeBackSlash(endEscape)}${close}`\n      : close === ']'\n        ? endEscape.length % 2 === 0\n          // A normal case, and it is a range notation\n          // '[bar]'\n          // '[bar\\\\\\\\]'\n          ? `[${sanitizeRange(range)}${endEscape}]`\n          // Invalid range notaton\n          // '[bar\\\\]' -> '[bar\\\\\\\\]'\n          : '[]'\n        : '[]'\n  ],\n\n  // ending\n  [\n    // 'js' will not match 'js.'\n    // 'ab' will not match 'abc'\n    /(?:[^*])$/,\n\n    // WTF!\n    // https://git-scm.com/docs/gitignore\n    // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)\n    // which re-fixes #24, #38\n\n    // > If there is a separator at the end of the pattern then the pattern\n    // > will only match directories, otherwise the pattern can match both\n    // > files and directories.\n\n    // 'js*' will not match 'a.js'\n    // 'js/' will not match 'a.js'\n    // 'js' will match 'a.js' and 'a.js/'\n    match => /\\/$/.test(match)\n      // foo/ will not match 'foo'\n      ? `${match}$`\n      // foo matches 'foo' and 'foo/'\n      : `${match}(?=$|\\\\/$)`\n  ],\n\n  // trailing wildcard\n  [\n    /(\\^|\\\\\\/)?\\\\\\*$/,\n    (_, p1) => {\n      const prefix = p1\n        // '\\^':\n        // '/*' does not match EMPTY\n        // '/*' does not match everything\n\n        // '\\\\\\/':\n        // 'abc/*' does not match 'abc/'\n        ? `${p1}[^/]+`\n\n        // 'a*' matches 'a'\n        // 'a*' matches 'aa'\n        : '[^/]*'\n\n      return `${prefix}(?=$|\\\\/$)`\n    }\n  ],\n]\n\n// A simple cache, because an ignore rule only has only one certain meaning\nconst regexCache = Object.create(null)\n\n// @param {pattern}\nconst makeRegex = (pattern, ignoreCase) => {\n  let source = regexCache[pattern]\n\n  if (!source) {\n    source = REPLACERS.reduce(\n      (prev, current) => prev.replace(current[0], current[1].bind(pattern)),\n      pattern\n    )\n    regexCache[pattern] = source\n  }\n\n  return ignoreCase\n    ? new RegExp(source, 'i')\n    : new RegExp(source)\n}\n\nconst isString = subject => typeof subject === 'string'\n\n// > A blank line matches no files, so it can serve as a separator for readability.\nconst checkPattern = pattern => pattern\n  && isString(pattern)\n  && !REGEX_TEST_BLANK_LINE.test(pattern)\n  && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern)\n\n  // > A line starting with # serves as a comment.\n  && pattern.indexOf('#') !== 0\n\nconst splitPattern = pattern => pattern.split(REGEX_SPLITALL_CRLF)\n\nclass IgnoreRule {\n  constructor (\n    origin,\n    pattern,\n    negative,\n    regex\n  ) {\n    this.origin = origin\n    this.pattern = pattern\n    this.negative = negative\n    this.regex = regex\n  }\n}\n\nconst createRule = (pattern, ignoreCase) => {\n  const origin = pattern\n  let negative = false\n\n  // > An optional prefix \"!\" which negates the pattern;\n  if (pattern.indexOf('!') === 0) {\n    negative = true\n    pattern = pattern.substr(1)\n  }\n\n  pattern = pattern\n  // > Put a backslash (\"\\\") in front of the first \"!\" for patterns that\n  // >   begin with a literal \"!\", for example, `\"\\!important!.txt\"`.\n  .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, '!')\n  // > Put a backslash (\"\\\") in front of the first hash for patterns that\n  // >   begin with a hash.\n  .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, '#')\n\n  const regex = makeRegex(pattern, ignoreCase)\n\n  return new IgnoreRule(\n    origin,\n    pattern,\n    negative,\n    regex\n  )\n}\n\nconst throwError = (message, Ctor) => {\n  throw new Ctor(message)\n}\n\nconst checkPath = (path, originalPath, doThrow) => {\n  if (!isString(path)) {\n    return doThrow(\n      `path must be a string, but got \\`${originalPath}\\``,\n      TypeError\n    )\n  }\n\n  // We don't know if we should ignore EMPTY, so throw\n  if (!path) {\n    return doThrow(`path must not be empty`, TypeError)\n  }\n\n  // Check if it is a relative path\n  if (checkPath.isNotRelative(path)) {\n    const r = '`path.relative()`d'\n    return doThrow(\n      `path should be a ${r} string, but got \"${originalPath}\"`,\n      RangeError\n    )\n  }\n\n  return true\n}\n\nconst isNotRelative = path => REGEX_TEST_INVALID_PATH.test(path)\n\ncheckPath.isNotRelative = isNotRelative\ncheckPath.convert = p => p\n\nclass Ignore {\n  constructor ({\n    ignorecase = true,\n    ignoreCase = ignorecase,\n    allowRelativePaths = false\n  } = {}) {\n    define(this, KEY_IGNORE, true)\n\n    this._rules = []\n    this._ignoreCase = ignoreCase\n    this._allowRelativePaths = allowRelativePaths\n    this._initCache()\n  }\n\n  _initCache () {\n    this._ignoreCache = Object.create(null)\n    this._testCache = Object.create(null)\n  }\n\n  _addPattern (pattern) {\n    // #32\n    if (pattern && pattern[KEY_IGNORE]) {\n      this._rules = this._rules.concat(pattern._rules)\n      this._added = true\n      return\n    }\n\n    if (checkPattern(pattern)) {\n      const rule = createRule(pattern, this._ignoreCase)\n      this._added = true\n      this._rules.push(rule)\n    }\n  }\n\n  // @param {Array<string> | string | Ignore} pattern\n  add (pattern) {\n    this._added = false\n\n    makeArray(\n      isString(pattern)\n        ? splitPattern(pattern)\n        : pattern\n    ).forEach(this._addPattern, this)\n\n    // Some rules have just added to the ignore,\n    // making the behavior changed.\n    if (this._added) {\n      this._initCache()\n    }\n\n    return this\n  }\n\n  // legacy\n  addPattern (pattern) {\n    return this.add(pattern)\n  }\n\n  //          |           ignored : unignored\n  // negative |   0:0   |   0:1   |   1:0   |   1:1\n  // -------- | ------- | ------- | ------- | --------\n  //     0    |  TEST   |  TEST   |  SKIP   |    X\n  //     1    |  TESTIF |  SKIP   |  TEST   |    X\n\n  // - SKIP: always skip\n  // - TEST: always test\n  // - TESTIF: only test if checkUnignored\n  // - X: that never happen\n\n  // @param {boolean} whether should check if the path is unignored,\n  //   setting `checkUnignored` to `false` could reduce additional\n  //   path matching.\n\n  // @returns {TestResult} true if a file is ignored\n  _testOne (path, checkUnignored) {\n    let ignored = false\n    let unignored = false\n\n    this._rules.forEach(rule => {\n      const {negative} = rule\n      if (\n        unignored === negative && ignored !== unignored\n        || negative && !ignored && !unignored && !checkUnignored\n      ) {\n        return\n      }\n\n      const matched = rule.regex.test(path)\n\n      if (matched) {\n        ignored = !negative\n        unignored = negative\n      }\n    })\n\n    return {\n      ignored,\n      unignored\n    }\n  }\n\n  // @returns {TestResult}\n  _test (originalPath, cache, checkUnignored, slices) {\n    const path = originalPath\n      // Supports nullable path\n      && checkPath.convert(originalPath)\n\n    checkPath(\n      path,\n      originalPath,\n      this._allowRelativePaths\n        ? RETURN_FALSE\n        : throwError\n    )\n\n    return this._t(path, cache, checkUnignored, slices)\n  }\n\n  _t (path, cache, checkUnignored, slices) {\n    if (path in cache) {\n      return cache[path]\n    }\n\n    if (!slices) {\n      // path/to/a.js\n      // ['path', 'to', 'a.js']\n      slices = path.split(SLASH)\n    }\n\n    slices.pop()\n\n    // If the path has no parent directory, just test it\n    if (!slices.length) {\n      return cache[path] = this._testOne(path, checkUnignored)\n    }\n\n    const parent = this._t(\n      slices.join(SLASH) + SLASH,\n      cache,\n      checkUnignored,\n      slices\n    )\n\n    // If the path contains a parent directory, check the parent first\n    return cache[path] = parent.ignored\n      // > It is not possible to re-include a file if a parent directory of\n      // >   that file is excluded.\n      ? parent\n      : this._testOne(path, checkUnignored)\n  }\n\n  ignores (path) {\n    return this._test(path, this._ignoreCache, false).ignored\n  }\n\n  createFilter () {\n    return path => !this.ignores(path)\n  }\n\n  filter (paths) {\n    return makeArray(paths).filter(this.createFilter())\n  }\n\n  // @returns {TestResult}\n  test (path) {\n    return this._test(path, this._testCache, true)\n  }\n}\n\nconst factory = options => new Ignore(options)\n\nconst isPathValid = path =>\n  checkPath(path && checkPath.convert(path), path, RETURN_FALSE)\n\nfactory.isPathValid = isPathValid\n\n// Fixes typescript\nfactory.default = factory\n\nmodule.exports = factory\n\n// Windows\n// --------------------------------------------------------------\n/* istanbul ignore if */\nif (\n  // Detect `process` so that it can run in browsers.\n  typeof process !== 'undefined'\n  && (\n    process.env && process.env.IGNORE_TEST_WIN32\n    || process.platform === 'win32'\n  )\n) {\n  /* eslint no-control-regex: \"off\" */\n  const makePosix = str => /^\\\\\\\\\\?\\\\/.test(str)\n  || /[\"<>|\\u0000-\\u001F]+/u.test(str)\n    ? str\n    : str.replace(/\\\\/g, '/')\n\n  checkPath.convert = makePosix\n\n  // 'C:\\\\foo'     <- 'C:\\\\foo' has been converted to 'C:/'\n  // 'd:\\\\foo'\n  const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\\//i\n  checkPath.isNotRelative = path =>\n    REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path)\n    || isNotRelative(path)\n}\n\n\n//# sourceURL=webpack://nature-cam/./node_modules/ignore/index.js?");

/***/ }),

/***/ "./node_modules/@sindresorhus/merge-streams/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@sindresorhus/merge-streams/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ mergeStreams)\n/* harmony export */ });\n/* harmony import */ var node_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:events */ \"node:events\");\n/* harmony import */ var node_stream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:stream */ \"node:stream\");\n/* harmony import */ var node_stream_promises__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:stream/promises */ \"node:stream/promises\");\n\n\n\n\nfunction mergeStreams(streams) {\n\tif (!Array.isArray(streams)) {\n\t\tthrow new TypeError(`Expected an array, got \\`${typeof streams}\\`.`);\n\t}\n\n\tfor (const stream of streams) {\n\t\tvalidateStream(stream);\n\t}\n\n\tconst objectMode = streams.some(({readableObjectMode}) => readableObjectMode);\n\tconst highWaterMark = getHighWaterMark(streams, objectMode);\n\tconst passThroughStream = new MergedStream({\n\t\tobjectMode,\n\t\twritableHighWaterMark: highWaterMark,\n\t\treadableHighWaterMark: highWaterMark,\n\t});\n\n\tfor (const stream of streams) {\n\t\tpassThroughStream.add(stream);\n\t}\n\n\tif (streams.length === 0) {\n\t\tendStream(passThroughStream);\n\t}\n\n\treturn passThroughStream;\n}\n\nconst getHighWaterMark = (streams, objectMode) => {\n\tif (streams.length === 0) {\n\t\t// @todo Use `node:stream` `getDefaultHighWaterMark(objectMode)` in next major release\n\t\treturn 16_384;\n\t}\n\n\tconst highWaterMarks = streams\n\t\t.filter(({readableObjectMode}) => readableObjectMode === objectMode)\n\t\t.map(({readableHighWaterMark}) => readableHighWaterMark);\n\treturn Math.max(...highWaterMarks);\n};\n\nclass MergedStream extends node_stream__WEBPACK_IMPORTED_MODULE_1__.PassThrough {\n\t#streams = new Set([]);\n\t#ended = new Set([]);\n\t#aborted = new Set([]);\n\t#onFinished;\n\n\tadd(stream) {\n\t\tvalidateStream(stream);\n\n\t\tif (this.#streams.has(stream)) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.#streams.add(stream);\n\n\t\tthis.#onFinished ??= onMergedStreamFinished(this, this.#streams);\n\t\tendWhenStreamsDone({\n\t\t\tpassThroughStream: this,\n\t\t\tstream,\n\t\t\tstreams: this.#streams,\n\t\t\tended: this.#ended,\n\t\t\taborted: this.#aborted,\n\t\t\tonFinished: this.#onFinished,\n\t\t});\n\n\t\tstream.pipe(this, {end: false});\n\t}\n\n\tremove(stream) {\n\t\tvalidateStream(stream);\n\n\t\tif (!this.#streams.has(stream)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tstream.unpipe(this);\n\t\treturn true;\n\t}\n}\n\nconst onMergedStreamFinished = async (passThroughStream, streams) => {\n\tupdateMaxListeners(passThroughStream, PASSTHROUGH_LISTENERS_COUNT);\n\tconst controller = new AbortController();\n\n\ttry {\n\t\tawait Promise.race([\n\t\t\tonMergedStreamEnd(passThroughStream, controller),\n\t\t\tonInputStreamsUnpipe(passThroughStream, streams, controller),\n\t\t]);\n\t} finally {\n\t\tcontroller.abort();\n\t\tupdateMaxListeners(passThroughStream, -PASSTHROUGH_LISTENERS_COUNT);\n\t}\n};\n\nconst onMergedStreamEnd = async (passThroughStream, {signal}) => {\n\tawait (0,node_stream_promises__WEBPACK_IMPORTED_MODULE_2__.finished)(passThroughStream, {signal, cleanup: true});\n};\n\nconst onInputStreamsUnpipe = async (passThroughStream, streams, {signal}) => {\n\tfor await (const [unpipedStream] of (0,node_events__WEBPACK_IMPORTED_MODULE_0__.on)(passThroughStream, 'unpipe', {signal})) {\n\t\tif (streams.has(unpipedStream)) {\n\t\t\tunpipedStream.emit(unpipeEvent);\n\t\t}\n\t}\n};\n\nconst validateStream = stream => {\n\tif (typeof stream?.pipe !== 'function') {\n\t\tthrow new TypeError(`Expected a readable stream, got: \\`${typeof stream}\\`.`);\n\t}\n};\n\nconst endWhenStreamsDone = async ({passThroughStream, stream, streams, ended, aborted, onFinished}) => {\n\tupdateMaxListeners(passThroughStream, PASSTHROUGH_LISTENERS_PER_STREAM);\n\tconst controller = new AbortController();\n\n\ttry {\n\t\tawait Promise.race([\n\t\t\tafterMergedStreamFinished(onFinished, stream),\n\t\t\tonInputStreamEnd({passThroughStream, stream, streams, ended, aborted, controller}),\n\t\t\tonInputStreamUnpipe({stream, streams, ended, aborted, controller}),\n\t\t]);\n\t} finally {\n\t\tcontroller.abort();\n\t\tupdateMaxListeners(passThroughStream, -PASSTHROUGH_LISTENERS_PER_STREAM);\n\t}\n\n\tif (streams.size === ended.size + aborted.size) {\n\t\tif (ended.size === 0 && aborted.size > 0) {\n\t\t\tabortStream(passThroughStream);\n\t\t} else {\n\t\t\tendStream(passThroughStream);\n\t\t}\n\t}\n};\n\n// This is the error thrown by `finished()` on `stream.destroy()`\nconst isAbortError = error => error?.code === 'ERR_STREAM_PREMATURE_CLOSE';\n\nconst afterMergedStreamFinished = async (onFinished, stream) => {\n\ttry {\n\t\tawait onFinished;\n\t\tabortStream(stream);\n\t} catch (error) {\n\t\tif (isAbortError(error)) {\n\t\t\tabortStream(stream);\n\t\t} else {\n\t\t\terrorStream(stream, error);\n\t\t}\n\t}\n};\n\nconst onInputStreamEnd = async ({passThroughStream, stream, streams, ended, aborted, controller: {signal}}) => {\n\ttry {\n\t\tawait (0,node_stream_promises__WEBPACK_IMPORTED_MODULE_2__.finished)(stream, {signal, cleanup: true, readable: true, writable: false});\n\t\tif (streams.has(stream)) {\n\t\t\tended.add(stream);\n\t\t}\n\t} catch (error) {\n\t\tif (signal.aborted || !streams.has(stream)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (isAbortError(error)) {\n\t\t\taborted.add(stream);\n\t\t} else {\n\t\t\terrorStream(passThroughStream, error);\n\t\t}\n\t}\n};\n\nconst onInputStreamUnpipe = async ({stream, streams, ended, aborted, controller: {signal}}) => {\n\tawait (0,node_events__WEBPACK_IMPORTED_MODULE_0__.once)(stream, unpipeEvent, {signal});\n\tstreams.delete(stream);\n\tended.delete(stream);\n\taborted.delete(stream);\n};\n\nconst unpipeEvent = Symbol('unpipe');\n\nconst endStream = stream => {\n\tif (stream.writable) {\n\t\tstream.end();\n\t}\n};\n\nconst abortStream = stream => {\n\tif (stream.readable || stream.writable) {\n\t\tstream.destroy();\n\t}\n};\n\n// `stream.destroy(error)` crashes the process with `uncaughtException` if no `error` event listener exists on `stream`.\n// We take care of error handling on user behalf, so we do not want this to happen.\nconst errorStream = (stream, error) => {\n\tif (!stream.destroyed) {\n\t\tstream.once('error', noop);\n\t\tstream.destroy(error);\n\t}\n};\n\nconst noop = () => {};\n\nconst updateMaxListeners = (passThroughStream, increment) => {\n\tconst maxListeners = passThroughStream.getMaxListeners();\n\tif (maxListeners !== 0 && maxListeners !== Number.POSITIVE_INFINITY) {\n\t\tpassThroughStream.setMaxListeners(maxListeners + increment);\n\t}\n};\n\n// Number of times `passThroughStream.on()` is called regardless of streams:\n//  - once due to `finished(passThroughStream)`\n//  - once due to `on(passThroughStream)`\nconst PASSTHROUGH_LISTENERS_COUNT = 2;\n\n// Number of times `passThroughStream.on()` is called per stream:\n//  - once due to `stream.pipe(passThroughStream)`\nconst PASSTHROUGH_LISTENERS_PER_STREAM = 1;\n\n\n//# sourceURL=webpack://nature-cam/./node_modules/@sindresorhus/merge-streams/index.js?");

/***/ }),

/***/ "./node_modules/globby/ignore.js":
/*!***************************************!*\
  !*** ./node_modules/globby/ignore.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GITIGNORE_FILES_PATTERN: () => (/* binding */ GITIGNORE_FILES_PATTERN),\n/* harmony export */   isGitIgnored: () => (/* binding */ isGitIgnored),\n/* harmony export */   isGitIgnoredSync: () => (/* binding */ isGitIgnoredSync),\n/* harmony export */   isIgnoredByIgnoreFiles: () => (/* binding */ isIgnoredByIgnoreFiles),\n/* harmony export */   isIgnoredByIgnoreFilesSync: () => (/* binding */ isIgnoredByIgnoreFilesSync)\n/* harmony export */ });\n/* harmony import */ var node_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:process */ \"node:process\");\n/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:fs */ \"node:fs\");\n/* harmony import */ var node_fs_promises__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:fs/promises */ \"node:fs/promises\");\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! node:path */ \"node:path\");\n/* harmony import */ var fast_glob__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! fast-glob */ \"./node_modules/fast-glob/out/index.js\");\n/* harmony import */ var ignore__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ignore */ \"./node_modules/ignore/index.js\");\n/* harmony import */ var slash__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! slash */ \"./node_modules/slash/index.js\");\n/* harmony import */ var unicorn_magic__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! unicorn-magic */ \"./node_modules/unicorn-magic/default.js\");\n/* harmony import */ var _utilities_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utilities.js */ \"./node_modules/globby/utilities.js\");\n\n\n\n\n\n\n\n\n\n\nconst defaultIgnoredDirectories = [\n\t'**/node_modules',\n\t'**/flow-typed',\n\t'**/coverage',\n\t'**/.git',\n];\nconst ignoreFilesGlobOptions = {\n\tabsolute: true,\n\tdot: true,\n};\n\nconst GITIGNORE_FILES_PATTERN = '**/.gitignore';\n\nconst applyBaseToPattern = (pattern, base) => (0,_utilities_js__WEBPACK_IMPORTED_MODULE_7__.isNegativePattern)(pattern)\n\t? '!' + node_path__WEBPACK_IMPORTED_MODULE_3__.posix.join(base, pattern.slice(1))\n\t: node_path__WEBPACK_IMPORTED_MODULE_3__.posix.join(base, pattern);\n\nconst parseIgnoreFile = (file, cwd) => {\n\tconst base = (0,slash__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(node_path__WEBPACK_IMPORTED_MODULE_3__.relative(cwd, node_path__WEBPACK_IMPORTED_MODULE_3__.dirname(file.filePath)));\n\n\treturn file.content\n\t\t.split(/\\r?\\n/)\n\t\t.filter(line => line && !line.startsWith('#'))\n\t\t.map(pattern => applyBaseToPattern(pattern, base));\n};\n\nconst toRelativePath = (fileOrDirectory, cwd) => {\n\tcwd = (0,slash__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(cwd);\n\tif (node_path__WEBPACK_IMPORTED_MODULE_3__.isAbsolute(fileOrDirectory)) {\n\t\tif ((0,slash__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(fileOrDirectory).startsWith(cwd)) {\n\t\t\treturn node_path__WEBPACK_IMPORTED_MODULE_3__.relative(cwd, fileOrDirectory);\n\t\t}\n\n\t\tthrow new Error(`Path ${fileOrDirectory} is not in cwd ${cwd}`);\n\t}\n\n\treturn fileOrDirectory;\n};\n\nconst getIsIgnoredPredicate = (files, cwd) => {\n\tconst patterns = files.flatMap(file => parseIgnoreFile(file, cwd));\n\tconst ignores = ignore__WEBPACK_IMPORTED_MODULE_5__().add(patterns);\n\n\treturn fileOrDirectory => {\n\t\tfileOrDirectory = (0,unicorn_magic__WEBPACK_IMPORTED_MODULE_8__.toPath)(fileOrDirectory);\n\t\tfileOrDirectory = toRelativePath(fileOrDirectory, cwd);\n\t\treturn fileOrDirectory ? ignores.ignores((0,slash__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(fileOrDirectory)) : false;\n\t};\n};\n\nconst normalizeOptions = (options = {}) => ({\n\tcwd: (0,unicorn_magic__WEBPACK_IMPORTED_MODULE_8__.toPath)(options.cwd) ?? node_process__WEBPACK_IMPORTED_MODULE_0__.cwd(),\n\tsuppressErrors: Boolean(options.suppressErrors),\n\tdeep: typeof options.deep === 'number' ? options.deep : Number.POSITIVE_INFINITY,\n\tignore: [...options.ignore ?? [], ...defaultIgnoredDirectories],\n});\n\nconst isIgnoredByIgnoreFiles = async (patterns, options) => {\n\tconst {cwd, suppressErrors, deep, ignore} = normalizeOptions(options);\n\n\tconst paths = await fast_glob__WEBPACK_IMPORTED_MODULE_4__(patterns, {\n\t\tcwd,\n\t\tsuppressErrors,\n\t\tdeep,\n\t\tignore,\n\t\t...ignoreFilesGlobOptions,\n\t});\n\n\tconst files = await Promise.all(\n\t\tpaths.map(async filePath => ({\n\t\t\tfilePath,\n\t\t\tcontent: await node_fs_promises__WEBPACK_IMPORTED_MODULE_2__.readFile(filePath, 'utf8'),\n\t\t})),\n\t);\n\n\treturn getIsIgnoredPredicate(files, cwd);\n};\n\nconst isIgnoredByIgnoreFilesSync = (patterns, options) => {\n\tconst {cwd, suppressErrors, deep, ignore} = normalizeOptions(options);\n\n\tconst paths = fast_glob__WEBPACK_IMPORTED_MODULE_4__.sync(patterns, {\n\t\tcwd,\n\t\tsuppressErrors,\n\t\tdeep,\n\t\tignore,\n\t\t...ignoreFilesGlobOptions,\n\t});\n\n\tconst files = paths.map(filePath => ({\n\t\tfilePath,\n\t\tcontent: node_fs__WEBPACK_IMPORTED_MODULE_1__.readFileSync(filePath, 'utf8'),\n\t}));\n\n\treturn getIsIgnoredPredicate(files, cwd);\n};\n\nconst isGitIgnored = options => isIgnoredByIgnoreFiles(GITIGNORE_FILES_PATTERN, options);\nconst isGitIgnoredSync = options => isIgnoredByIgnoreFilesSync(GITIGNORE_FILES_PATTERN, options);\n\n\n//# sourceURL=webpack://nature-cam/./node_modules/globby/ignore.js?");

/***/ }),

/***/ "./node_modules/globby/index.js":
/*!**************************************!*\
  !*** ./node_modules/globby/index.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertPathToPattern: () => (/* binding */ convertPathToPattern),\n/* harmony export */   generateGlobTasks: () => (/* binding */ generateGlobTasks),\n/* harmony export */   generateGlobTasksSync: () => (/* binding */ generateGlobTasksSync),\n/* harmony export */   globby: () => (/* binding */ globby),\n/* harmony export */   globbyStream: () => (/* binding */ globbyStream),\n/* harmony export */   globbySync: () => (/* binding */ globbySync),\n/* harmony export */   isDynamicPattern: () => (/* binding */ isDynamicPattern),\n/* harmony export */   isGitIgnored: () => (/* reexport safe */ _ignore_js__WEBPACK_IMPORTED_MODULE_7__.isGitIgnored),\n/* harmony export */   isGitIgnoredSync: () => (/* reexport safe */ _ignore_js__WEBPACK_IMPORTED_MODULE_7__.isGitIgnoredSync)\n/* harmony export */ });\n/* harmony import */ var node_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:process */ \"node:process\");\n/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:fs */ \"node:fs\");\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:path */ \"node:path\");\n/* harmony import */ var _sindresorhus_merge_streams__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @sindresorhus/merge-streams */ \"./node_modules/@sindresorhus/merge-streams/index.js\");\n/* harmony import */ var fast_glob__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! fast-glob */ \"./node_modules/fast-glob/out/index.js\");\n/* harmony import */ var path_type__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! path-type */ \"./node_modules/path-type/index.js\");\n/* harmony import */ var unicorn_magic__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! unicorn-magic */ \"./node_modules/unicorn-magic/default.js\");\n/* harmony import */ var _ignore_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ignore.js */ \"./node_modules/globby/ignore.js\");\n/* harmony import */ var _utilities_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utilities.js */ \"./node_modules/globby/utilities.js\");\n\n\n\n\n\n\n\n\n\n\nconst assertPatternsInput = patterns => {\n\tif (patterns.some(pattern => typeof pattern !== 'string')) {\n\t\tthrow new TypeError('Patterns must be a string or an array of strings');\n\t}\n};\n\nconst normalizePathForDirectoryGlob = (filePath, cwd) => {\n\tconst path = (0,_utilities_js__WEBPACK_IMPORTED_MODULE_5__.isNegativePattern)(filePath) ? filePath.slice(1) : filePath;\n\treturn node_path__WEBPACK_IMPORTED_MODULE_2__.isAbsolute(path) ? path : node_path__WEBPACK_IMPORTED_MODULE_2__.join(cwd, path);\n};\n\nconst getDirectoryGlob = ({directoryPath, files, extensions}) => {\n\tconst extensionGlob = extensions?.length > 0 ? `.${extensions.length > 1 ? `{${extensions.join(',')}}` : extensions[0]}` : '';\n\treturn files\n\t\t? files.map(file => node_path__WEBPACK_IMPORTED_MODULE_2__.posix.join(directoryPath, `**/${node_path__WEBPACK_IMPORTED_MODULE_2__.extname(file) ? file : `${file}${extensionGlob}`}`))\n\t\t: [node_path__WEBPACK_IMPORTED_MODULE_2__.posix.join(directoryPath, `**${extensionGlob ? `/*${extensionGlob}` : ''}`)];\n};\n\nconst directoryToGlob = async (directoryPaths, {\n\tcwd = node_process__WEBPACK_IMPORTED_MODULE_0__.cwd(),\n\tfiles,\n\textensions,\n} = {}) => {\n\tconst globs = await Promise.all(directoryPaths.map(async directoryPath =>\n\t\t(await (0,path_type__WEBPACK_IMPORTED_MODULE_4__.isDirectory)(normalizePathForDirectoryGlob(directoryPath, cwd))) ? getDirectoryGlob({directoryPath, files, extensions}) : directoryPath),\n\t);\n\n\treturn globs.flat();\n};\n\nconst directoryToGlobSync = (directoryPaths, {\n\tcwd = node_process__WEBPACK_IMPORTED_MODULE_0__.cwd(),\n\tfiles,\n\textensions,\n} = {}) => directoryPaths.flatMap(directoryPath => (0,path_type__WEBPACK_IMPORTED_MODULE_4__.isDirectorySync)(normalizePathForDirectoryGlob(directoryPath, cwd)) ? getDirectoryGlob({directoryPath, files, extensions}) : directoryPath);\n\nconst toPatternsArray = patterns => {\n\tpatterns = [...new Set([patterns].flat())];\n\tassertPatternsInput(patterns);\n\treturn patterns;\n};\n\nconst checkCwdOption = cwd => {\n\tif (!cwd) {\n\t\treturn;\n\t}\n\n\tlet stat;\n\ttry {\n\t\tstat = node_fs__WEBPACK_IMPORTED_MODULE_1__.statSync(cwd);\n\t} catch {\n\t\treturn;\n\t}\n\n\tif (!stat.isDirectory()) {\n\t\tthrow new Error('The `cwd` option must be a path to a directory');\n\t}\n};\n\nconst normalizeOptions = (options = {}) => {\n\toptions = {\n\t\t...options,\n\t\tignore: options.ignore ?? [],\n\t\texpandDirectories: options.expandDirectories ?? true,\n\t\tcwd: (0,unicorn_magic__WEBPACK_IMPORTED_MODULE_6__.toPath)(options.cwd),\n\t};\n\n\tcheckCwdOption(options.cwd);\n\n\treturn options;\n};\n\nconst normalizeArguments = function_ => async (patterns, options) => function_(toPatternsArray(patterns), normalizeOptions(options));\nconst normalizeArgumentsSync = function_ => (patterns, options) => function_(toPatternsArray(patterns), normalizeOptions(options));\n\nconst getIgnoreFilesPatterns = options => {\n\tconst {ignoreFiles, gitignore} = options;\n\n\tconst patterns = ignoreFiles ? toPatternsArray(ignoreFiles) : [];\n\tif (gitignore) {\n\t\tpatterns.push(_ignore_js__WEBPACK_IMPORTED_MODULE_7__.GITIGNORE_FILES_PATTERN);\n\t}\n\n\treturn patterns;\n};\n\nconst getFilter = async options => {\n\tconst ignoreFilesPatterns = getIgnoreFilesPatterns(options);\n\treturn createFilterFunction(\n\t\tignoreFilesPatterns.length > 0 && await (0,_ignore_js__WEBPACK_IMPORTED_MODULE_7__.isIgnoredByIgnoreFiles)(ignoreFilesPatterns, options),\n\t);\n};\n\nconst getFilterSync = options => {\n\tconst ignoreFilesPatterns = getIgnoreFilesPatterns(options);\n\treturn createFilterFunction(\n\t\tignoreFilesPatterns.length > 0 && (0,_ignore_js__WEBPACK_IMPORTED_MODULE_7__.isIgnoredByIgnoreFilesSync)(ignoreFilesPatterns, options),\n\t);\n};\n\nconst createFilterFunction = isIgnored => {\n\tconst seen = new Set();\n\n\treturn fastGlobResult => {\n\t\tconst pathKey = node_path__WEBPACK_IMPORTED_MODULE_2__.normalize(fastGlobResult.path ?? fastGlobResult);\n\n\t\tif (seen.has(pathKey) || (isIgnored && isIgnored(pathKey))) {\n\t\t\treturn false;\n\t\t}\n\n\t\tseen.add(pathKey);\n\n\t\treturn true;\n\t};\n};\n\nconst unionFastGlobResults = (results, filter) => results.flat().filter(fastGlobResult => filter(fastGlobResult));\n\nconst convertNegativePatterns = (patterns, options) => {\n\tconst tasks = [];\n\n\twhile (patterns.length > 0) {\n\t\tconst index = patterns.findIndex(pattern => (0,_utilities_js__WEBPACK_IMPORTED_MODULE_5__.isNegativePattern)(pattern));\n\n\t\tif (index === -1) {\n\t\t\ttasks.push({patterns, options});\n\t\t\tbreak;\n\t\t}\n\n\t\tconst ignorePattern = patterns[index].slice(1);\n\n\t\tfor (const task of tasks) {\n\t\t\ttask.options.ignore.push(ignorePattern);\n\t\t}\n\n\t\tif (index !== 0) {\n\t\t\ttasks.push({\n\t\t\t\tpatterns: patterns.slice(0, index),\n\t\t\t\toptions: {\n\t\t\t\t\t...options,\n\t\t\t\t\tignore: [\n\t\t\t\t\t\t...options.ignore,\n\t\t\t\t\t\tignorePattern,\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\tpatterns = patterns.slice(index + 1);\n\t}\n\n\treturn tasks;\n};\n\nconst normalizeExpandDirectoriesOption = (options, cwd) => ({\n\t...(cwd ? {cwd} : {}),\n\t...(Array.isArray(options) ? {files: options} : options),\n});\n\nconst generateTasks = async (patterns, options) => {\n\tconst globTasks = convertNegativePatterns(patterns, options);\n\n\tconst {cwd, expandDirectories} = options;\n\n\tif (!expandDirectories) {\n\t\treturn globTasks;\n\t}\n\n\tconst directoryToGlobOptions = normalizeExpandDirectoriesOption(expandDirectories, cwd);\n\n\treturn Promise.all(\n\t\tglobTasks.map(async task => {\n\t\t\tlet {patterns, options} = task;\n\n\t\t\t[\n\t\t\t\tpatterns,\n\t\t\t\toptions.ignore,\n\t\t\t] = await Promise.all([\n\t\t\t\tdirectoryToGlob(patterns, directoryToGlobOptions),\n\t\t\t\tdirectoryToGlob(options.ignore, {cwd}),\n\t\t\t]);\n\n\t\t\treturn {patterns, options};\n\t\t}),\n\t);\n};\n\nconst generateTasksSync = (patterns, options) => {\n\tconst globTasks = convertNegativePatterns(patterns, options);\n\tconst {cwd, expandDirectories} = options;\n\n\tif (!expandDirectories) {\n\t\treturn globTasks;\n\t}\n\n\tconst directoryToGlobSyncOptions = normalizeExpandDirectoriesOption(expandDirectories, cwd);\n\n\treturn globTasks.map(task => {\n\t\tlet {patterns, options} = task;\n\t\tpatterns = directoryToGlobSync(patterns, directoryToGlobSyncOptions);\n\t\toptions.ignore = directoryToGlobSync(options.ignore, {cwd});\n\t\treturn {patterns, options};\n\t});\n};\n\nconst globby = normalizeArguments(async (patterns, options) => {\n\tconst [\n\t\ttasks,\n\t\tfilter,\n\t] = await Promise.all([\n\t\tgenerateTasks(patterns, options),\n\t\tgetFilter(options),\n\t]);\n\n\tconst results = await Promise.all(tasks.map(task => fast_glob__WEBPACK_IMPORTED_MODULE_3__(task.patterns, task.options)));\n\treturn unionFastGlobResults(results, filter);\n});\n\nconst globbySync = normalizeArgumentsSync((patterns, options) => {\n\tconst tasks = generateTasksSync(patterns, options);\n\tconst filter = getFilterSync(options);\n\tconst results = tasks.map(task => fast_glob__WEBPACK_IMPORTED_MODULE_3__.sync(task.patterns, task.options));\n\treturn unionFastGlobResults(results, filter);\n});\n\nconst globbyStream = normalizeArgumentsSync((patterns, options) => {\n\tconst tasks = generateTasksSync(patterns, options);\n\tconst filter = getFilterSync(options);\n\tconst streams = tasks.map(task => fast_glob__WEBPACK_IMPORTED_MODULE_3__.stream(task.patterns, task.options));\n\tconst stream = (0,_sindresorhus_merge_streams__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(streams).filter(fastGlobResult => filter(fastGlobResult));\n\n\t// TODO: Make it return a web stream at some point.\n\t// return Readable.toWeb(stream);\n\n\treturn stream;\n});\n\nconst isDynamicPattern = normalizeArgumentsSync(\n\t(patterns, options) => patterns.some(pattern => fast_glob__WEBPACK_IMPORTED_MODULE_3__.isDynamicPattern(pattern, options)),\n);\n\nconst generateGlobTasks = normalizeArguments(generateTasks);\nconst generateGlobTasksSync = normalizeArgumentsSync(generateTasksSync);\n\n\n\nconst {convertPathToPattern} = fast_glob__WEBPACK_IMPORTED_MODULE_3__;\n\n\n//# sourceURL=webpack://nature-cam/./node_modules/globby/index.js?");

/***/ }),

/***/ "./node_modules/globby/utilities.js":
/*!******************************************!*\
  !*** ./node_modules/globby/utilities.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isNegativePattern: () => (/* binding */ isNegativePattern)\n/* harmony export */ });\nconst isNegativePattern = pattern => pattern[0] === '!';\n\n\n//# sourceURL=webpack://nature-cam/./node_modules/globby/utilities.js?");

/***/ }),

/***/ "./node_modules/path-type/index.js":
/*!*****************************************!*\
  !*** ./node_modules/path-type/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isDirectory: () => (/* binding */ isDirectory),\n/* harmony export */   isDirectorySync: () => (/* binding */ isDirectorySync),\n/* harmony export */   isFile: () => (/* binding */ isFile),\n/* harmony export */   isFileSync: () => (/* binding */ isFileSync),\n/* harmony export */   isSymlink: () => (/* binding */ isSymlink),\n/* harmony export */   isSymlinkSync: () => (/* binding */ isSymlinkSync)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"?54c0\");\n\n\nasync function isType(fsStatType, statsMethodName, filePath) {\n\tif (typeof filePath !== 'string') {\n\t\tthrow new TypeError(`Expected a string, got ${typeof filePath}`);\n\t}\n\n\ttry {\n\t\tconst stats = await fs__WEBPACK_IMPORTED_MODULE_0__.promises[fsStatType](filePath);\n\t\treturn stats[statsMethodName]();\n\t} catch (error) {\n\t\tif (error.code === 'ENOENT') {\n\t\t\treturn false;\n\t\t}\n\n\t\tthrow error;\n\t}\n}\n\nfunction isTypeSync(fsStatType, statsMethodName, filePath) {\n\tif (typeof filePath !== 'string') {\n\t\tthrow new TypeError(`Expected a string, got ${typeof filePath}`);\n\t}\n\n\ttry {\n\t\treturn fs__WEBPACK_IMPORTED_MODULE_0__[fsStatType](filePath)[statsMethodName]();\n\t} catch (error) {\n\t\tif (error.code === 'ENOENT') {\n\t\t\treturn false;\n\t\t}\n\n\t\tthrow error;\n\t}\n}\n\nconst isFile = isType.bind(null, 'stat', 'isFile');\nconst isDirectory = isType.bind(null, 'stat', 'isDirectory');\nconst isSymlink = isType.bind(null, 'lstat', 'isSymbolicLink');\nconst isFileSync = isTypeSync.bind(null, 'statSync', 'isFile');\nconst isDirectorySync = isTypeSync.bind(null, 'statSync', 'isDirectory');\nconst isSymlinkSync = isTypeSync.bind(null, 'lstatSync', 'isSymbolicLink');\n\n\n//# sourceURL=webpack://nature-cam/./node_modules/path-type/index.js?");

/***/ }),

/***/ "./node_modules/slash/index.js":
/*!*************************************!*\
  !*** ./node_modules/slash/index.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ slash)\n/* harmony export */ });\nfunction slash(path) {\n\tconst isExtendedLengthPath = path.startsWith('\\\\\\\\?\\\\');\n\n\tif (isExtendedLengthPath) {\n\t\treturn path;\n\t}\n\n\treturn path.replace(/\\\\/g, '/');\n}\n\n\n//# sourceURL=webpack://nature-cam/./node_modules/slash/index.js?");

/***/ }),

/***/ "./node_modules/unicorn-magic/default.js":
/*!***********************************************!*\
  !*** ./node_modules/unicorn-magic/default.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   delay: () => (/* binding */ delay)\n/* harmony export */ });\nasync function delay({seconds, milliseconds} = {}) {\n\tlet duration;\n\tif (typeof seconds === 'number') {\n\t\tduration = seconds * 1000;\n\t} else if (typeof milliseconds === 'number') {\n\t\tduration = milliseconds;\n\t} else {\n\t\tthrow new TypeError('Expected an object with either `seconds` or `milliseconds`.');\n\t}\n\n\treturn new Promise(resolve => {\n\t\tsetTimeout(resolve, duration);\n\t});\n}\n\n\n//# sourceURL=webpack://nature-cam/./node_modules/unicorn-magic/default.js?");

/***/ })

}]);